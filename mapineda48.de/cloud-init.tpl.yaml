#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - software-properties-common
  - fuse3
  - jq

bootcmd:
  - mkdir -p /opt/mapineda48/proxy
  - mkdir -p /opt/mapineda48/docker-refresh
  - mkdir -p /opt/mapineda48/docker-webhook

write_files:
  - path: /etc/blobfuse2.yaml
    permissions: '0644'
    content: |
      version: 2
      logging:
        type: syslog
        level: LOG_INFO

      components:
        - libfuse
        - azstorage

      azstorage:
        type: block
        account-name: ${storage_account_name}
        account-key: ${storage_account_key}
        container: deploy

      libfuse:
        mount-path: /mnt/deploy
        allow-other: true
        mount-options:
          - uid=1000
          - gid=999
          - umask=002

  - path: /etc/fuse.conf
    append: true
    content: |
      user_allow_other

  - path: /etc/systemd/system/mapineda48-blobfuse2-deploy.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Mount Blob Storage with Blobfuse2
      After=network-online.target
      Wants=network-online.target

      [Service]
      User=azureuser
      Group=docker
      Type=simple
      ExecStart=/usr/bin/blobfuse2 mount /mnt/deploy --config-file=/etc/blobfuse2.yaml --allow-other
      Restart=on-failure
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target

  - path: /opt/mapineda48/docker-refresh/server.js
    permissions: '0755'
    content: |
      #!/usr/bin/env node

      const http = require("http");
      const fs = require("fs");
      const { exec } = require("child_process");
      const Docker = require("dockerode");

      const SOCKET_PATH = "/tmp/docker-refresh.sock";
      const docker = new Docker({ socketPath: "/var/run/docker.sock" });
      const ALLOWED_IMAGES = ["mapineda48/msgpack-vite-agape-app:latest"];
      const COMPOSE_FILE = "/opt/mapineda48/proxy/docker-compose.yml";

      // Eliminar socket si existe
      if (fs.existsSync(SOCKET_PATH)) {
        fs.unlinkSync(SOCKET_PATH);
      }

      // --- Servidor HTTP principal ---
      const server = http.createServer(async (req, res) => {
        if (req.method !== "POST" || req.url !== "/") {
          res.writeHead(404);
          return res.end();
        }

        let body = [];
        req.on("data", chunk => body.push(chunk));
        req.on("end", async () => {
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ ok: true }));

          try {
            const { image } = JSON.parse(Buffer.concat(body).toString());
            if (!image) throw new Error("Falta el nombre de la imagen");

            if (!ALLOWED_IMAGES.includes(image)) {
              console.error(`❌ Imagen no permitida: $${image}`);
              return;
            }

            console.log(`↻ Verificando si la imagen cambió: $${image}`);

            const [before] = await docker.listImages({ filters: { reference: [image] } });

            await pullImage(image);

            const [after] = await docker.listImages({ filters: { reference: [image] } });

            if (before?.Id === after?.Id) {
              console.log(`→ La imagen está sincronizada, no se reinician servicios.`);
              return;
            }

            console.log("✓ Imagen actualizada, reiniciando servicios...");

            const containers = await docker.listContainers({ all: true });

            console.log(`🔎 Buscando containers con image: $${image} o ID: $${before.Id}`);

            const matching = containers.filter(c => {
              console.log(`🧩 $${c.Names[0]} → Image: $${c.Image}, ImageID: $${c.ImageID}`);

              return (
                c.ImageID?.includes(before.Id?.replace("sha256:", "")) ||
                c.Image === image // fallback
              );
            });

            console.log(`🔍 Contenedores encontrados: $${matching.length}`);

            const serviceNames = new Set();
            for (const c of matching) {
              const service = c.Labels?.["com.docker.compose.service"];
              if (service) {
                serviceNames.add(service);
              } else {
                console.warn(`⚠️ Contenedor sin label compose.service: $${c.Names[0]}`);
              }
            }

            for (const service of serviceNames) {
              console.log(`🔄 Reiniciando servicio: $${service}`);
              await recreateService(service);
            }

          } catch (err) {
            console.error("❌ Error procesando el webhook:", err);
          }
        });
      });

      server.listen(SOCKET_PATH, () => {
        fs.chmodSync(SOCKET_PATH, 0o766);
        console.log(`🟢 Webhook escuchando en $${SOCKET_PATH}`);
      });

      // --- Funciones auxiliares ---

      async function pullImage(image) {
        return new Promise((resolve, reject) => {
          docker.pull(image, (err, stream) => {
            if (err) return reject(err);
            docker.modem.followProgress(
              stream,
              () => resolve(),
              (event) => {
                if (event.status) {
                  process.stdout.write(`→ $${event.status} $${event.progress || ""}\n`);
                }
              }
            );
          });
        });
      }

      async function recreateService(serviceName) {
        try {
          await execPromise(`docker compose -f $${COMPOSE_FILE} rm -sf $${serviceName}`);
          console.log(`✓ Servicio $${serviceName} eliminado`);
        } catch (err) {
          console.warn(`⚠️  Eliminar servicio falló (puede que no existiera): $${serviceName}`);
        }

        try {
          await execPromise(`docker compose -f $${COMPOSE_FILE} up -d $${serviceName}`);
          console.log(`✓ Servicio $${serviceName} levantado`);
        } catch (err) {
          console.error(`❌ Error levantando $${serviceName}:`, err.message);
        }
      }

      function execPromise(command) {
        return new Promise((resolve, reject) => {
          exec(command, (err, stdout, stderr) => {
            if (err) return reject(err);
            if (stdout) console.log(stdout.trim());
            if (stderr) console.warn(stderr.trim());
            resolve();
          });
        });
      }

  - path: /etc/systemd/system/mapineda48-docker-refresh.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Docker Image Refresh Socket Server
      After=network.target docker.service
      Requires=docker.service

      [Service]
      Environment=NODE_PATH=/usr/lib/node_modules
      ExecStart=/usr/bin/env node /opt/mapineda48/docker-refresh/server.js
      Restart=always
      RestartSec=5
      User=root
      StandardOutput=journal
      StandardError=journal

      [Install]
      WantedBy=multi-user.target

  - path: /opt/mapineda48/docker-webhook/webhook.js
    permissions: '0755'
    content: |
      #!/usr/bin/env node
      import http from "http";
      import fs from "fs";

      const SOCKET_PATH = "/tmp/docker-refresh.sock";
      const SECRET = process.env.WEBHOOK_SECRET;

      const server = http.createServer((req, res) => {
        const url = new URL(req.url, `http://localhost`);

        if (req.method !== "POST" || url.pathname !== "/") {
          res.writeHead(403);
          return res.end();
        }

        const receivedSecret = url.searchParams.get("token");
        if (!SECRET || receivedSecret !== SECRET) {
          console.log(`fail token $${SECRET} !== $${receivedSecret}`)

          res.writeHead(403);
          return res.end("Forbidden");
        }

        let body = [];
        req.on("data", chunk => body.push(chunk));
        req.on("end", () => {
          const payload = Buffer.concat(body).toString();
          const image = JSON.parse(payload)?.push_data?.tag
            ? `$${JSON.parse(payload).repository.repo_name}:$${JSON.parse(payload).push_data.tag}`
            : null;

          if (!image) {
            res.writeHead(400);
            return res.end("No image found");
          }

          const socketReq = http.request({
            socketPath: SOCKET_PATH,
            path: "/",
            method: "POST",
            headers: { "Content-Type": "application/json" },
          }, socketRes => {
            res.writeHead(socketRes.statusCode || 500);
            socketRes.pipe(res);
          });

          socketReq.on("error", err => {
            console.error("❌ Error comunicando con el socket:", err);
            res.writeHead(500);
            res.end("Error interno");
          });

          socketReq.write(JSON.stringify({ image }));
          socketReq.end();
        });
      });

      server.listen(3000, () => {
        console.log("🚀 Webhook escuchando en puerto 3000");
      });

  - path: /opt/mapineda48/proxy/docker-compose.yml
    permissions: '0644'
    owner: azureuser:azureuser
    content: |
      services:
        nginx-proxy:
          image: nginxproxy/nginx-proxy:1.2
          container_name: mapineda48-proxy
          ports:
            - "80:80"
            - "443:443"
          environment:
            TRUST_DOWNSTREAM_PROXY: "false"
          volumes:
            - /mnt/deploy/mapineda48.vm/ngnix/certs:/etc/nginx/certs
            - /mnt/deploy/mapineda48.vm/ngnix/vhost:/etc/nginx/vhost.d
            - /opt/mapineda48/proxy/html:/usr/share/nginx/html
            - /var/run/docker.sock:/tmp/docker.sock:ro
          networks:
            - mapineda48-net

        nginx-proxy-acme:
          image: nginxproxy/acme-companion:2.2
          container_name: mapineda48-acme
          environment:
            DEFAULT_EMAIL: ${default_email_acme}
            ACME_CA_URI: https://acme-v02.api.letsencrypt.org/directory
            NGINX_PROXY_CONTAINER: mapineda48-proxy
          volumes:
            - /mnt/deploy/mapineda48.vm/ngnix/certs:/etc/nginx/certs
            - /mnt/deploy/mapineda48.vm/ngnix/vhost:/etc/nginx/vhost.d
            - /opt/mapineda48/proxy/html:/usr/share/nginx/html
            - /mnt/deploy/mapineda48.vm/acme:/etc/acme.sh
            - /var/run/docker.sock:/var/run/docker.sock:ro
          networks:
            - mapineda48-net

        dockerhub-webhook:
          image: node:22-alpine
          container_name: mapineda48-dockerhub-webhook
          environment:
            VIRTUAL_HOST: ${dockerhub_webhook_fqdn}
            LETSENCRYPT_HOST: ${dockerhub_webhook_fqdn}
            VIRTUAL_PORT: 3000
            WEBHOOK_SECRET: ${dockerhub_webhook_secret}
          working_dir: /app
          volumes:
            - /opt/mapineda48/docker-webhook:/app
            - /tmp/docker-refresh.sock:/tmp/docker-refresh.sock:ro
          command: ["node", "webhook.js"]
          networks:
            - mapineda48-net

        agape-app:
          image: mapineda48/msgpack-vite-agape-app:latest
          container_name: mapineda48-agape-app
          restart: unless-stopped
          environment:
            NODE_ENV: "production"
            DATABASE_URI: "${database_uri}"
            AZURE_CONNECTION_STRING: "${azure_connection_string}"
            VIRTUAL_HOST: ${agape_app_fqdn}
            LETSENCRYPT_HOST: ${agape_app_fqdn}
            VIRTUAL_PORT: 3000
            AGAPE_TENANT: "${agape_tenant}"
            AGAPE_SECRET: "${agape_secret}"
            AGAPE_ADMIN: "${agape_admin}"
            AGAPE_PASSWORD: "${agape_password}"
          expose:
            - "3000"
          networks:
            - mapineda48-net
            
      networks:
        mapineda48-net:
          name: mapineda48-net

  - path: /etc/systemd/system/mapineda48-docker-compose.service
    permissions: '0644'
    owner: root:root
    content: |
      [Unit]
      Description=Docker Compose Service for mapineda48
      Requires=docker.service
      After=docker.service

      [Service]
      Type=oneshot
      WorkingDirectory=/opt/mapineda48/proxy
      ExecStart=/usr/bin/docker compose up
      ExecStop=/usr/bin/docker compose down
      RemainAfterExit=true

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Permisos a carpteas de trabajo
  - chown -R azureuser:azureuser /opt/mapineda48

  # Instalar Docker
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  - echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
  - apt-get update
  - apt-get install -y docker-ce docker-ce-cli containerd.io

  # Crear grupo fuse si no existe y agregar usuario a grupos necesarios
  - groupadd --system fuse || true
  - usermod -aG docker azureuser
  - usermod -aG fuse azureuser

  # Instalar Blobfuse2
  - curl -L https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -o packages-microsoft-prod.deb
  - dpkg -i packages-microsoft-prod.deb
  - apt-get update
  - apt-get install -y blobfuse2

  # Crear punto de montaje
  - mkdir -p /mnt/deploy
  - chown azureuser:docker /mnt/deploy
  - chmod 775 /mnt/deploy

  # Iniciar blob2
  - blobfuse2 mount /mnt/deploy --config-file=/etc/blobfuse2.yaml --allow-other

  # Crear carpetas necesarias
  - mkdir -p /mnt/deploy/mapineda48.vm/ngnix/certs
  - mkdir -p /mnt/deploy/mapineda48.vm/ngnix/vhost
  - mkdir -p /mnt/deploy/mapineda48.vm/ngnix/html/.well-known/acme-challenge
  - mkdir -p /mnt/deploy/mapineda48.vm/acme
  - mkdir -p /opt/mapineda48/proxy/html
  - cp -r /mnt/deploy/mapineda48.vm/ngnix/html/* /opt/mapineda48/proxy/html/ || true

  # Permisos para que grupo docker acceda a los volúmenes
  - chown -R azureuser:docker /mnt/deploy/mapineda48.vm
  - chmod -R 775 /mnt/deploy/mapineda48.vm

  # Nodejs
  - curl -fsSL https://deb.nodesource.com/setup_lts.x | bash -
  - apt-get install -y nodejs
  - npm install -g dockerode@4.0.7

  # Habilitar el servicios
  - systemctl enable mapineda48-blobfuse2-deploy
  - systemctl enable mapineda48-docker-refresh
  - systemctl enable mapineda48-docker-compose

  # Reiniciar la VM para aplicar cambios de grupos
  - reboot